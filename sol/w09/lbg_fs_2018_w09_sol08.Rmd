---
title: Livestock Breeding and Genomics - Solution 8
author: Peter von Rohr
date: 2018-11-16
#output: pdf_document 
output:
  bookdown::pdf_document2:
    toc: false
    number_sections: false
    keep_tex: false
header-includes:
 \usepackage{longtable}
 \usepackage{float}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, results = 'asis', fig.pos = 'H')
knitr::knit_hooks$set(hook_convert_odg = rmddochelper::hook_convert_odg)
```

## Problem 1: Numerator Relationship Matrix
Construct the numerator relationship matrix $A$ for the following pedigree and verify the result using the function `getA()` from package `pedigreemm`. 

```{r ex8p1ped, echo=FALSE, results='asis'}
tbl_ped_ex8p1 <- tibble::data_frame(Animal = c(5, 6, 7, 8, 9, 10),
                                    Sire   = c(1, 1, 4, 4, 4, 4),
                                    Dam    = c(2, 3, 5, 5, 6, 6))
knitr::kable(tbl_ped_ex8p1, 
             booktabs = TRUE,
             longtable = TRUE,
             caption   = "Pedigree For Constructing Numerator Relationship Matrix")
```


### Solution
The numerator relationship is constructed using the follownig step-wise procedure. The following rules are used to compute the single elements.

* __Case 1__: If both parents $s$ and $d$ of animal $i$ are known then 
    + the diagonal element $(A)_{ii}$ corresponds to:  $(A)_{ii} = 1 + F_i = 1 + {1\over 2} (A)_{sd}$ and
    + the offdiagonal element $(A)_{ji}$ is computed as:  $(A)_{ji} = {1\over 2} ((A)_{js} + (A)_{jd})$
    + because $A$ is symmetric $(A)_{ji} = (A)_{ij}$
    
* __Case 2__: If only one parent $s$ is known and assumed unrelated to the mate
    + $(A)_{ii} = 1$
    + $(A)_{ij} = (A)_{ji} = {1\over 2} ((A)_{js}$
    
* __Case 3__: If both parents are unknown    
    + $(A)_{ii} = 1$
    + $(A)_{ij} = (A)_{ji} = 0$


#### Step 1
First, we extend the pedigree given in Table \@ref(tab:ex8p1ped). All animals without parents are added at the top of the pedigree. This results in the matrix shown in Table \@ref(tab:ex8p1pedext). 

```{r ex8p1pedext, echo=FALSE, results='asis'}
n_nr_ani_ex8p1pedext <- max(tbl_ped_ex8p1$Animal)
n_nr_founder_ex8p1pedext <- min(tbl_ped_ex8p1$Animal) - 1
tbl_ped_exp8p1ext <- tibble::data_frame(Animal = c(1:n_nr_ani_ex8p1pedext),
                                        Sire   = c(rep(NA, n_nr_founder_ex8p1pedext), tbl_ped_ex8p1$Sire),
                                        Dam    = c(rep(NA, n_nr_founder_ex8p1pedext), tbl_ped_ex8p1$Dam))
knitr::kable(tbl_ped_exp8p1ext,
             booktabs  = TRUE,
             longtable = TRUE,
             caption   = "Extended Pedigree")
```

Because the pedigree in Table \@ref(tab:ex8p1pedext) is already ordered such that parents are before offspring, we can directly go to the next step.


#### Step 2
We start with an empty numerator relationship matrix $A$. The matrix $A$ has dimensions $`r n_nr_ani_ex8p1pedext` \times `r n_nr_ani_ex8p1pedext`$ 

```{r ex8p1mataempty, echo=FALSE, results='asis'}
matA_empty_ex8p1 <- matrix(NA, nrow = n_nr_ani_ex8p1pedext, ncol = n_nr_ani_ex8p1pedext)
### # display
cat("$$\n")
cat("A = \\left[")
cat(paste(rmddochelper::sConvertMatrixToLaTexArray(pmatAMatrix = matA_empty_ex8p1), collapse = "\n"), "\n")
cat("\\right]\n")
cat("$$\n")
```


#### Step 3
The single elements of $A$ are computed according to the rules listed above. 


```{r ex8p1extractfirstanimal, echo=FALSE, results='hide'}
n_ex8p1_first_animal <- tbl_ped_exp8p1ext$Animal[1]
```

The computation is started with animal $`r n_ex8p1_first_animal`$. The first element is always the diagonal-element that corresponds to animal that we are currently looking at. For animal $`r n_ex8p1_first_animal`$ the diagonal element is $(A)_{`r n_ex8p1_first_animal``r n_ex8p1_first_animal`}$. Because animal `r n_ex8p1_first_animal` has not parents, we are in case 3 for the diagonal element. If an animal has unknown parents, it also means that the animals's inbreeding coefficient $F_i$ is $0$. Hence

$$(A)_{`r n_ex8p1_first_animal``r n_ex8p1_first_animal`} = 1$$

Now we have the first element of our numerator relationship matrix.

```{r ex8p1matafirstelement, echo=FALSE, results='asis'}
matA_empty_ex8p1[n_ex8p1_first_animal,n_ex8p1_first_animal] <- 1
### # display
cat("$$\n")
cat("A = \\left[")
cat(paste(rmddochelper::sConvertMatrixToLaTexArray(pmatAMatrix = matA_empty_ex8p1), collapse = "\n"), "\n")
cat("\\right]\n")
cat("$$\n")
```


#### Step 4
The next elements that need to be computed are the off-diagnoal element on row $1$. Elements $A_{12}$, $A_{13}$ and $A_{14}$ correspond to the additive genetic relationship between animal $1$ and animals $2$, $3$ and $4$. Because animals $2$, $3$ and $4$ all have unknown parents, we are for all three elements in case 3, hence we can state

$$(A)_{12} = (A)_{13} = (A)_{14} = 0$$

```{r ex8p1matafirstrowfounder, echo=FALSE, results='asis'}
matA_empty_ex8p1[n_ex8p1_first_animal,2:4] <- 0
```

For the remaining elements of the first row of $A$, the elements correspond to the additive genetic relationship between animal $1$ and animals $5$ to $10$. Because animals $5$ to $10$ all have known parents, we have to use case 1 in the above formulated rules.


```{r ex8p1matafirstrowanimal5, echo=FALSE, results='asis'}
n_cur_ani <- 5
n_cur_sire <- tbl_ped_exp8p1ext$Sire[n_cur_ani]
n_cur_dam <- tbl_ped_exp8p1ext$Dam[n_cur_ani]
matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_ani] <- 0.5 * (matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_sire] + matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_dam])
```

\begin{equation}
(A)_{`r n_ex8p1_first_animal``r n_cur_ani`}  =  {1\over 2}\left( (A)_{`r n_ex8p1_first_animal``r n_cur_sire`} + (A)_{`r n_ex8p1_first_animal``r n_cur_dam`} \right)
                                             =  {1\over 2}\left( `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_sire]` + `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_dam]`  \right)
                                             =  `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_ani]` \notag
\end{equation}


```{r ex8p1matafirstrowanimal6, echo=FALSE, results='asis'}
n_cur_ani <- 6
n_cur_sire <- tbl_ped_exp8p1ext$Sire[n_cur_ani]
n_cur_dam <- tbl_ped_exp8p1ext$Dam[n_cur_ani]
matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_ani] <- 0.5 * (matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_sire] + matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_dam])
```

\begin{equation}
(A)_{`r n_ex8p1_first_animal``r n_cur_ani`}  =  {1\over 2}\left( (A)_{`r n_ex8p1_first_animal``r n_cur_sire`} + (A)_{`r n_ex8p1_first_animal``r n_cur_dam`} \right)
                                             =  {1\over 2}\left( `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_sire]` + `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_dam]`  \right)
                                             =  `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_ani]` \notag
\end{equation}



```{r ex8p1matafirstrowanimal7, echo=FALSE, results='asis'}
n_cur_ani <- 7
n_cur_sire <- tbl_ped_exp8p1ext$Sire[n_cur_ani]
n_cur_dam <- tbl_ped_exp8p1ext$Dam[n_cur_ani]
matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_ani] <- 0.5 * (matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_sire] + matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_dam])
```

\begin{equation}
(A)_{`r n_ex8p1_first_animal``r n_cur_ani`}  =  {1\over 2}\left( (A)_{`r n_ex8p1_first_animal``r n_cur_sire`} + (A)_{`r n_ex8p1_first_animal``r n_cur_dam`} \right)
                                             =  {1\over 2}\left( `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_sire]` + `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_dam]`  \right)
                                             =  `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_ani]` \notag
\end{equation}



```{r ex8p1matafirstrowanimal8, echo=FALSE, results='asis'}
n_cur_ani <- 8
n_cur_sire <- tbl_ped_exp8p1ext$Sire[n_cur_ani]
n_cur_dam <- tbl_ped_exp8p1ext$Dam[n_cur_ani]
matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_ani] <- 0.5 * (matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_sire] + matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_dam])
```

\begin{equation}
(A)_{`r n_ex8p1_first_animal``r n_cur_ani`}  =  {1\over 2}\left( (A)_{`r n_ex8p1_first_animal``r n_cur_sire`} + (A)_{`r n_ex8p1_first_animal``r n_cur_dam`} \right)
                                             =  {1\over 2}\left( `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_sire]` + `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_dam]`  \right)
                                             =  `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_ani]` \notag
\end{equation}



```{r ex8p1matafirstrowanimal9, echo=FALSE, results='asis'}
n_cur_ani <- 9
n_cur_sire <- tbl_ped_exp8p1ext$Sire[n_cur_ani]
n_cur_dam <- tbl_ped_exp8p1ext$Dam[n_cur_ani]
matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_ani] <- 0.5 * (matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_sire] + matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_dam])
```

\begin{equation}
(A)_{`r n_ex8p1_first_animal``r n_cur_ani`}  =  {1\over 2}\left( (A)_{`r n_ex8p1_first_animal``r n_cur_sire`} + (A)_{`r n_ex8p1_first_animal``r n_cur_dam`} \right)
                                             =  {1\over 2}\left( `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_sire]` + `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_dam]`  \right)
                                             =  `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_ani]` \notag
\end{equation}


```{r ex8p1matafirstrowanimal10, echo=FALSE, results='asis'}
n_cur_ani <- 10
n_cur_sire <- tbl_ped_exp8p1ext$Sire[n_cur_ani]
n_cur_dam <- tbl_ped_exp8p1ext$Dam[n_cur_ani]
matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_ani] <- 0.5 * (matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_sire] + matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_dam])
```

\begin{equation}
(A)_{`r n_ex8p1_first_animal``r n_cur_ani`}  =  {1\over 2}\left( (A)_{`r n_ex8p1_first_animal``r n_cur_sire`} + (A)_{`r n_ex8p1_first_animal``r n_cur_dam`} \right)
                                             =  {1\over 2}\left( `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_sire]` + `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_dam]`  \right)
                                             =  `r matA_empty_ex8p1[n_ex8p1_first_animal,n_cur_ani]` \notag
\end{equation}

As a result, we have the first row of $A$

```{r ex8p1matafirstrowresult, echo=FALSE, results='asis'}
### # display
cat("$$\n")
cat("A = \\left[")
cat(paste(rmddochelper::sConvertMatrixToLaTexArray(pmatAMatrix = matA_empty_ex8p1), collapse = "\n"), "\n")
cat("\\right]\n")
cat("$$\n")
```


#### Step 5
Copy the first row to the first column

```{r ex8p1matafirstcolresult, echo=FALSE, results='asis'}
matA_empty_ex8p1[2:n_nr_ani_ex8p1pedext,1] <- matA_empty_ex8p1[1, 2:n_nr_ani_ex8p1pedext]
### # display
cat("$$\n")
cat("A = \\left[")
cat(paste(rmddochelper::sConvertMatrixToLaTexArray(pmatAMatrix = matA_empty_ex8p1), collapse = "\n"), "\n")
cat("\\right]\n")
cat("$$\n")
```


#### Step 6
Continue the same way with rows $2$ to $10$


#### Verification
We first have to specify the pedigree, before being able to get the numerator relationship matrix

```{r ex8p1mataverify, echo=TRUE, results='markup'}
n_nr_animals <- 10
suppressPackageStartupMessages( library(pedigreemm) )
ped <- pedigree(sire = c(NA,NA,NA,NA,1,1,4,4,4,4), 
                dam = c(NA,NA,NA,NA,2,3,5,5,6,6), 
                label = as.character(1:n_nr_animals))
mata_ex8p1_verify <- getA(ped = ped)
mata_ex8p1_verify
```

In the above result all elements which are $0$ are represented by a dot.


## Problem 2: BLUP Animal Model
Use the following dataset to predict breeding values for all animals.





### Solution
